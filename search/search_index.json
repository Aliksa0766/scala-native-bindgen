{"docs":[{"location":"/index.html","text":"","title":"Scala Native Bindgen"},{"location":"/index.html#scala-native-bindgen","text":"This tool generates Scala Native bindings from C headers. Itâ€™s built upon clang and LibTooling and thus respects the conventions of clang-tools.","title":"Scala Native Bindgen"},{"location":"/index.html#license","text":"This project is distributed under the Scala license. See LICENSE.txt for details","title":"License"},{"location":"/obtaining-bindgen/index.html","text":"","title":"Obtaining Bindgen"},{"location":"/obtaining-bindgen/index.html#obtaining-bindgen","text":"There are 3 ways to obtain bindgen:\nUse the sbt plugin Use docker container Build binary with CMake Build binary with docker-compose","title":"Obtaining Bindgen"},{"location":"/obtaining-bindgen/sbt-plugin.html","text":"","title":"Using the sbt plugin"},{"location":"/obtaining-bindgen/sbt-plugin.html#using-the-sbt-plugin","text":"To add the sbt plugin to your project add the following lines in project/plugins.sbt:\naddSbtPlugin(\"org.scala-native.bindgen\" % \"sbt-scala-native-bindgen\" % \"0.3.0-RC0\")\n\nresolvers += Resolver.bintrayIvyRepo(\"scala-native-bindgen\", \"sbt-plugin\")\nresolvers += Resolver.bintrayRepo(\"scala-native-bindgen\", \"maven\")\nNext configure the plugin using the nativeBindings setting scoped to either Compile or Test. The NativeBinding type to configure each binding that should be generated.\nNote By default the scala-native-bindgen executable is downloaded automatically for supported platforms. Set version in nativeBindgen (unscoped) to configure the version of the scala-native-bindgen to use if you want a version different from the version of the sbt plugin. In case your platform is not supported, you must compile scala-native-bindgen yourself and configure the path to the executable using nativeBindgenPath, e.g.: nativeBindgenPath := file(\"/path/to/scala-native-bindgen\")\nExample settings:\nenablePlugins(ScalaNativeBindgenPlugin)\ninConfig(Compile)(\n  Def.settings(\n    nativeBindings += {\n      NativeBinding((resourceDirectory in Compile).value / \"header.h\")\n        .name(\"MyLib\")\n        .packageName(\"org.example.mylib\")\n        .link(\"mylib\"), // Will pass `-lmylib` to the linker\n        .excludePrefix(\"__\")\n      }\n  ))\nRunning nativeBindgen will generate a file named target/scala-2.x/src_managed/main/sbt-scala-native-bindgen/MyLib.scala containing something along the following lines:\npackage org.example.mylib\n\nimport scala.scalanative._\nimport scala.scalanative.native._\n\n@native.link(\"mylib\")\n@native.extern\nobject MyLib {\n  // ... left out for brevity ...\n}","title":"Using the sbt plugin"},{"location":"/obtaining-bindgen/docker-container.html","text":"","title":"Using Docker Container"},{"location":"/obtaining-bindgen/docker-container.html#using-docker-container","text":"This option requires Docker.\nDownload docker image with the binary:\ndocker pull scalabindgen/scala-native-bindgen\nMount directories with required header files and run bindgen:\ndocker run -v \"$(pwd)\":/src -v /usr/include:/usr/include \\\n  --rm scalabindgen/scala-native-bindgen \\\n  relative/path/to/my_header.h --name my_header --\nThe docker image does not contain standard headers so it is important to mount all system include directories that are used by the header file passed to scala-native-bindgen.\nSee the docker-bindgen.sh script for how to wrap the dockerized program. The $CWD of the container is /src which should be mounted from $(pwd) in case relative paths are used.\nNote, the scalabindgen/scala-native-bindgen:latest image is updated on each merge to the master branch.","title":"Using Docker Container"},{"location":"/obtaining-bindgen/cmake.html","text":"","title":"Building with CMake"},{"location":"/obtaining-bindgen/cmake.html#building-with-cmake","text":"Building scala-native-bindgen requires the following tools and libraries:\nCMake version 3.9 or higher LLVM and Clang version 5.0 or 6.0. nlohmann/json version 3.1.2 or higher\n# On apt-based systems\napt install cmake clang-$LLVM_VERSION libclang-$LLVM_VERSION-dev llvm-$LLVM_VERSION-dev\n\n# With `brew`\nbrew install cmake llvm@6\nTo run the tests you also need the required Scala Native libraries. See the Scala Native setup guide for instructions on installing the dependencies.\nmkdir -p bindgen/target\ncd bindgen/target\ncmake ..\nmake\n./scala-native-bindgen --name ctype /usr/include/ctype.h --\nTo build a statically linked executable pass -DSTATIC_LINKING=ON when invoking cmake:\ncmake -DSTATIC_LINKING=ON ..\nAdditional compiler and linker flags may be passed as environment variable sor their CMake equivalent, e.g. to compile with debug symbols the following are the same:\ncmake -DCMAKE_CXX_FLAGS=-g ..\nCXXFLAGS=-g cmake ..","title":"Building with CMake"},{"location":"/obtaining-bindgen/cmake.html#testing","text":"The tests assume that the above instructions for building scala-native-bindgen from source has been followed.\ncd tests\nsbt test","title":"Testing"},{"location":"/obtaining-bindgen/docker-compose.html","text":"","title":"Building with docker-compose"},{"location":"/obtaining-bindgen/docker-compose.html#building-with-docker-compose","text":"You can use docker-compose to build and test the program:\n# Build the docker image with LLVM version 6.0.\ndocker-compose build ubuntu-18.04-llvm-6.0\n# Build the bindgen tool and run the tests.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 ./script/test.sh\n# Run the bindgen tool inside the container.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 \\\n    bindgen/target/scala-native-bindgen --name union tests/samples/Union.h --","title":"Building with docker-compose"},{"location":"/command-line-usage/index.html","text":"","title":"Command Line Usage"},{"location":"/command-line-usage/index.html#command-line-usage","text":"Calling the tool is pretty easy, you need to specify the file(s) and the name of the created bindings.\nscala-native-bindgen --name uv /usr/include/uv.h --\nRunning the previous command wild also yield warnings along with the translation. To keep only the bindings please redirect the output to a file like this:\nscala-native-bindgen --name uv /usr/include/uv.h -- > uv.scala","title":"Command Line Usage"},{"location":"/command-line-usage/index.html#bindgen-options","text":"Option Description --link Library to link with, e.g. --link uv for libuv. --no-link Library does not require linking. --name Scala object name that contains bindings. Default value set to library name. --package Package name of generated Scala file. --exclude-prefix Functions and unused typedefs will be removed if their names have given prefix. --binding-config Path to a config file that contains the information about bindings that should be reused. See Integrating Bindings for more information. --extra-arg Additional argument to append to the compiler command line. --extra-arg-before Additional argument to prepend to the compiler command line.","title":"Bindgen Options"},{"location":"/integrating-bindings/index.html","text":"","title":"Integrating Bindings"},{"location":"/integrating-bindings/index.html#integrating-bindings","text":"To reuse already generated bindings create a config.json file that defines which headers correspond to which Scala objects:\n{\n  \"_stdio.h\": \"scala.scalanative.native.stdio\",\n  \"/full/path/to/regexp4.h\": \"bindings.regexp4\"\n}\nBindgen assumes that type names in header files match type names in generated binding (spaces in struct, union and enum names are replaces with underscores), but it is possible to specify custom names mapping:\n{\n  \"hiredis.h\": {\n    \"object\": \"bindings.hiredis.hiredis\",\n    \"names\": {\n      \"redisContext\": \"Context\"\n    }\n  }\n}\nProvide a path to config.json to bindgen using --binding-config command-line option or NativeBinding.bindingConfig sbt plugin option (see Using the sbt plugin).","title":"Integrating Bindings"},{"location":"/limitations/index.html","text":"","title":"Limitations"},{"location":"/limitations/index.html#limitations","text":"There are multiple unsupported cases that should be considered when generating bindings.","title":"Limitations"},{"location":"/limitations/index.html#passing-structs-by-value","text":"Scala Native does not support passing structs by value, bindgen skips such functions.\nstruct MyStruct {\n    int a;\n};\n\nstruct MyStruct returnStruct(); // skipped\n\nvoid handleStruct(struct MyStruct mystr); // skipped\nTo support such cases one should generate bindings for C wrapper functions that use pointers to structs instead of actual structs.","title":"Passing structs by value"},{"location":"/limitations/index.html#limited-support-of-defines","text":"#defines for literals and variables are supported. For other types of #defines, write wrapper functions that return defined values.\n// Supported\n#define ESC 0x1b            /* Defines for numerical and string literals. */\nextern const int pi_const;\n#define PI pi_const         /* Defines aliasing extern variables. */\n\n// Not supported (non-exhaustive list)\n#define COLS  (getenv(\"COLS\") ? atoi(getenv(\"COLS\")) : 80)\n#define MAX(a, b) (a > b ? a : b)","title":"Limited support of #defines"},{"location":"/limitations/index.html#reusing-generated-bindings","text":"There is no way to reuse already generated bindings. Bindgen outputs bindings also for headers that were included in a given header. See #2.","title":"Reusing generated bindings"},{"location":"/limitations/index.html#type-qualifiers","text":"Type qualifiers const, volatile and restrict are not supported.","title":"Type qualifiers"},{"location":"/limitations/index.html#updating-extern-variables","text":"Extern variables are read-only. See scala-native/scala-native#202.","title":"Updating extern variables"},{"location":"/using-generated-bindings/README.html","text":"","title":"Using Generated Bindings"},{"location":"/using-generated-bindings/README.html#using-generated-bindings","text":"Consider following header file:\nstruct point {\n    float x;\n    float y;\n};\n\nstruct vector {\n    struct point a;\n    struct point b;\n};\n\nstruct vector *add(struct vector *v1, struct vector *v2);\nBindgen will generate type aliases for the structs, binding for function add and helper functions that make usage of structs easier.\nimport scala.scalanative._\nimport scala.scalanative.native._\n\n@native.link(\"mylib\")\n@native.extern\nobject mylib {\n  type struct_point = native.CStruct2[native.CFloat, native.CFloat]\n  type struct_vector = native.CStruct2[struct_point, struct_point]\n  def add(v1: native.Ptr[struct_vector], v2: native.Ptr[struct_vector]): native.Ptr[struct_vector] = native.extern\n}\n\nimport mylib._\n\nobject mylibHelpers {\n\n  implicit class struct_point_ops(val p: native.Ptr[struct_point]) extends AnyVal {\n    def x: native.CFloat = !p._1\n    def x_=(value: native.CFloat): Unit = !p._1 = value\n    def y: native.CFloat = !p._2\n    def y_=(value: native.CFloat): Unit = !p._2 = value\n  }\n\n  def struct_point()(implicit z: native.Zone): native.Ptr[struct_point] = native.alloc[struct_point]\n\n  implicit class struct_vector_ops(val p: native.Ptr[struct_vector]) extends AnyVal {\n    def a: native.Ptr[struct_point] = p._1\n    def a_=(value: native.Ptr[struct_point]): Unit = !p._1 = !value\n    def b: native.Ptr[struct_point] = p._2\n    def b_=(value: native.Ptr[struct_point]): Unit = !p._2 = !value\n  }\n\n  def struct_vector()(implicit z: native.Zone): native.Ptr[struct_vector] = native.alloc[struct_vector]\n}\nLetâ€™s write code that creates two vectors, adds them and prints resulting vector.\nFirst we need to create points for vectors. We will use native.Zone to allocate struct (more information on memory management can be found here: Scala Native memory management).\nHelper object mylibHelpers contains function for struct allocation. To import it use import mylibHelpers._\nLetâ€™s create points for first vector:\nimport mylibHelpers._\nimport scala.scalanative.native.Zone\n\nobject Hello extends App {\n  Zone { implicit zone =>\n   val vec1p1 = struct_point()\n   val vec1p2 = struct_point()\n  }\n}\nNow we want to set fields of created points. Scala Native provides access to fields by using _N methods where N is index of a field (see Scala Native memory layout types).\nBindgen generates implicit helper classes that wrap calls to _N in functions with meaningful names. We already imported helper class, so we can use the functions:\nvec1p1.x = 0\nvec1p1.y = 1\n\nvec1p2.x = 6\nvec1p2.y = 3\nLets create first vector. Note that struct_vector contains fields of type struct_point but setters accept variables of type native.Ptr[struct_point]. It helps to avoid Scala Native limitation that does not allow passing structs and arrays by value (see scala-native/scala-native#555).\nval vec1 = struct_vector()\nvec1.a = vec1p1\nvec1.b = vec1p2\nRepeat these steps to create second vector. Once both vectors are created we can call add function and print the result:\nval vec3 = mylib.add(vec1, vec2)\nprintln(s\"(${vec3.a.x}, ${vec3.a.y}), (${vec3.b.x}, ${vec3.b.y})\")","title":"Using Generated Bindings"}]}