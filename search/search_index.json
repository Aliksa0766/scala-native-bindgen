{"docs":[{"location":"/index.html","text":"","title":"Scala Native Bindgen"},{"location":"/index.html#scala-native-bindgen","text":"Scala Native Bindgen is a binding generator for Scala Native that uses Clang to parse C header files and generates Scala binding definitions.","title":"Scala Native Bindgen"},{"location":"/index.html#features","text":"possibility to reuse types from existing bindings. type casts that make recursive structs be valid Scala Native structs. implicit classes for structs and unions that make fields access easier. implicit classes that add setters and getters to structs with more than 22 fields (such structs in Scala Native are represented as arrays of bytes). literal defines embedding #define MY_CONSTANT 42 → val MY_CONSTANT: native.CInt = 42. read-only bindings for extern variables (such variables cannot be updated due to Scala Native limitation). declarations filtering by prefix.","title":"Features"},{"location":"/index.html#license","text":"This project is distributed under the Scala license. See LICENSE.txt for details","title":"License"},{"location":"/index.html#table-of-contents","text":"Generating Bindings with sbt Generating Bindings with the CLI Command Line Usage Options Using Generated Bindings Integrating Bindings Limitations Passing structs by value Limited support of #defines Reusing generated bindings Type qualifiers Updating extern variables Bindings POSIX Examples Iconv - Character set conversion Example Utf8proc - UTF-8 text processing Example Contributor’s Guide Guide for contributors Developer Workflow Coding Guidelines Building the executable with CMake Building the executable with docker-compose Contributing Bindings Adding a new Bindings Update all Bindings Release Workflow","title":"Table of Contents"},{"location":"/sbt.html","text":"","title":"Generating Bindings with sbt"},{"location":"/sbt.html#generating-bindings-with-sbt","text":"To add the sbt plugin to your project add the following lines in project/plugins.sbt:\naddSbtPlugin(\"org.scala-native.bindgen\" % \"sbt-scala-native-bindgen\" % VERSION)\n\nresolvers += Resolver.bintrayIvyRepo(\"scala-native-bindgen\", \"sbt-plugins\")\nresolvers += Resolver.bintrayRepo(\"scala-native-bindgen\", \"maven\")\nReplacing VERSION with 0.3.0-RC2 to use the latest version.\nNext configure the plugin using the nativeBindings setting scoped to either Compile or Test. The NativeBinding type to configure each binding that should be generated.\nNote By default the scala-native-bindgen executable is downloaded automatically for supported platforms. Set version in nativeBindgen (unscoped) to configure the version of the scala-native-bindgen to use if you want a version different from the version of the sbt plugin. In case your platform is not supported, you must compile scala-native-bindgen yourself and configure the path to the executable using nativeBindgenPath, e.g.: nativeBindgenPath := file(\"/path/to/scala-native-bindgen\")\nExample settings:\nenablePlugins(ScalaNativeBindgenPlugin)\n\ninConfig(Compile)(\n  Def.settings(\n    nativeBindings += {\n      NativeBinding(resourceDirectory.value / \"stdlib.h\")\n        .name(\"stdlib\")\n        .packageName(\"org.example.app.stdlib\")\n        .excludePrefix(\"__\")\n    }\n  ))\nGiven that the stdlib.h header file contains:\nint access(const char *path, int mode);\nint read(int fildes, void *buf, int nbyte);\nint printf(const char *restrict format, ...);\nint __excluded(void);\nRunning nativeBindgen will generate a file named target/scala-2.11/src_managed/main/sbt-scala-native-bindgen/stdlib.scala containing something along the following lines:\npackage org.example.app.stdlib\n\nimport scala.scalanative._\nimport scala.scalanative.native._\n\n@native.extern\nobject stdlib {\n  def access(path: native.CString, mode: native.CInt): native.CInt = native.extern\n  def read(fildes: native.CInt, buf: native.Ptr[Byte], nbyte: native.CInt): native.CInt = native.extern\n  def printf(format: native.CString, varArgs: native.CVararg*): native.CInt = native.extern\n}","title":"Generating Bindings with sbt"},{"location":"/cli.html","text":"","title":"Generating Bindings with the CLI"},{"location":"/cli.html#generating-bindings-with-the-cli","text":"Statically linked executables are provided with each release for Linux and macOS. Head over to the releases page to download the latest version for your platform.\nNote In the following we assume you have renamed the downloaded scala-native-bindgen-$PLATFORM file to scala-native-bindgen.","title":"Generating Bindings with the CLI"},{"location":"/cli.html#command-line-usage","text":"When generating bindings with the CLI, you need to specify the header file and provide the name of the created bindings using the --name option:\nscala-native-bindgen --name fnmatch /usr/include/fnmatch.h --\nWhen running the CLI it will also yield warnings along with the translation. To keep only the bindings please redirect the output to a file like this:\nscala-native-bindgen --name fnmatch /usr/include/fnmatch.h -- > fnmatch.scala\nBy default it is assumed that you want to link with a library based on the name option. In case the name of the library to link with is different from the binding name provide the library name using --link:\nscala-native-bindgen --name zlib --link z /usr/include/zlib.h --\nIf the binding does not require any linking, pass --no-link:\nscala-native-bindgen --name fnmatch --no-link /usr/include/fnmatch.h --\nFor libraries that require linking you m","title":"Command Line Usage"},{"location":"/cli.html#options","text":"The generated bindings can be configured using the different options and it is also possible to pass arguments directly to the Clang compiler using the --extra-arg* options.\nOption Description --link Library to link with, e.g. --link uv for libuv. --no-link Library does not require linking. --name Scala object name that contains bindings. Default value set to library name. --package Package name of generated Scala file. --exclude-prefix Functions and unused typedefs will be removed if their names have given prefix. --binding-config Path to a config file that contains the information about bindings that should be reused. See Integrating Bindings for more information. --extra-arg Additional argument to append to the compiler command line. --extra-arg-before Additional argument to prepend to the compiler command line.","title":"Options"},{"location":"/using-generated-bindings.html","text":"","title":"Using Generated Bindings"},{"location":"/using-generated-bindings.html#using-generated-bindings","text":"Consider following header file:\nstruct point {\n    float x;\n    float y;\n};\n\nstruct vector {\n    struct point a;\n    struct point b;\n};\n\nstruct vector *add(struct vector *v1, struct vector *v2);\nBindgen will generate type aliases for the structs, binding for function add and helper functions that make usage of structs easier.\npackage org.example\n\nimport scala.scalanative._\nimport scala.scalanative.native._\n\n@native.link(\"vector\")\n@native.extern\nobject vector {\n  type struct_point = native.CStruct2[native.CFloat, native.CFloat]\n  type struct_vector = native.CStruct2[struct_point, struct_point]\n  def add(v1: native.Ptr[struct_vector], v2: native.Ptr[struct_vector]): native.Ptr[struct_vector] = native.extern\n\n  object implicits {\n    implicit class struct_point_ops(val p: native.Ptr[struct_point]) extends AnyVal {\n      def x: native.CFloat = !p._1\n      def x_=(value: native.CFloat): Unit = !p._1 = value\n      def y: native.CFloat = !p._2\n      def y_=(value: native.CFloat): Unit = !p._2 = value\n    }\n    def struct_point()(implicit z: native.Zone): native.Ptr[struct_point] = native.alloc[struct_point]\n\n    implicit class struct_vector_ops(val p: native.Ptr[struct_vector]) extends AnyVal {\n      def a: native.Ptr[struct_point] = p._1\n      def a_=(value: native.Ptr[struct_point]): Unit = !p._1 = !value\n      def b: native.Ptr[struct_point] = p._2\n      def b_=(value: native.Ptr[struct_point]): Unit = !p._2 = !value\n    }\n    def struct_vector()(implicit z: native.Zone): native.Ptr[struct_vector] = native.alloc[struct_vector]\n  }\n}\nLet’s write code that creates two vectors, adds them and prints resulting vector.\nFirst we need to create points for vectors. We will use native.Zone to allocate struct (more information on memory management can be found here: Scala Native memory management).\nHelper object mylibHelpers contains function for struct allocation. To import it use import mylibHelpers._\nLet’s create points for first vector:\nimport scala.scalanative.native.Zone\nimport org.example.vector\nimport org.example.vector.implicits._\n\nZone { implicit zone =>\n  val vec1p1 = struct_point()\n  val vec1p2 = struct_point()\n}\nNow we want to set fields of created points. Scala Native provides access to fields by using _N methods where N is index of a field (see Scala Native memory layout types).\nBindgen generates implicit helper classes that wrap calls to _N in functions with meaningful names. We already imported helper class, so we can use the functions:\nvec1p1.x = 0\nvec1p1.y = 1\n\nvec1p2.x = 6\nvec1p2.y = 3\nLets create first vector. Note that struct_vector contains fields of type struct_point but setters accept variables of type native.Ptr[struct_point]. It helps to avoid Scala Native limitation that does not allow passing structs and arrays by value (see scala-native/scala-native#555).\nval vec1 = struct_vector()\nvec1.a = vec1p1\nvec1.b = vec1p2\nRepeat these steps to create second vector. Once both vectors are created we can call add function and print the result:\nval vec3 = vector.add(vec1, vec2)\nprintln(s\"(${vec3.a.x}, ${vec3.a.y}), (${vec3.b.x}, ${vec3.b.y})\")","title":"Using Generated Bindings"},{"location":"/integrating-bindings.html","text":"","title":"Integrating Bindings"},{"location":"/integrating-bindings.html#integrating-bindings","text":"To reuse already generated bindings create a config.json file that defines which headers correspond to which Scala objects:\n{\n  \"_stdio.h\": \"scala.scalanative.native.stdio\",\n  \"/full/path/to/regexp4.h\": \"bindings.regexp4\"\n}\nBindgen assumes that type names in header files match type names in generated binding (spaces in struct, union and enum names are replaces with underscores), but it is possible to specify custom names mapping:\n{\n  \"hiredis.h\": {\n    \"object\": \"bindings.hiredis.hiredis\",\n    \"names\": {\n      \"redisContext\": \"Context\"\n    }\n  }\n}\nProvide a path to config.json to bindgen using --binding-config command-line option or NativeBinding.bindingConfig sbt plugin option (see Using the sbt plugin).","title":"Integrating Bindings"},{"location":"/limitations.html","text":"","title":"Limitations"},{"location":"/limitations.html#limitations","text":"There are multiple unsupported cases that should be considered when generating bindings.\nPassing structs by value Limited support of #defines Reusing generated bindings Type qualifiers Updating extern variables","title":"Limitations"},{"location":"/limitations.html#passing-structs-by-value","text":"Scala Native does not support passing structs by value, bindgen skips such functions.\nstruct MyStruct {\n    int a;\n};\n\nstruct MyStruct returnStruct(); // skipped\n\nvoid handleStruct(struct MyStruct mystr); // skipped\nTo support such cases one should generate bindings for C wrapper functions that use pointers to structs instead of actual structs.","title":"Passing structs by value"},{"location":"/limitations.html#limited-support-of-defines","text":"#defines for literals and variables are supported. For other types of #defines, write wrapper functions that return defined values.\n// Supported\n#define ESC 0x1b            /* Defines for numerical and string literals. */\nextern const int pi_const;\n#define PI pi_const         /* Defines aliasing extern variables. */\n\n// Not supported (non-exhaustive list)\n#define COLS  (getenv(\"COLS\") ? atoi(getenv(\"COLS\")) : 80)\n#define MAX(a, b) (a > b ? a : b)","title":"Limited support of #defines"},{"location":"/limitations.html#reusing-generated-bindings","text":"There is no way to reuse already generated bindings. Bindgen outputs bindings also for headers that were included in a given header. See #2.","title":"Reusing generated bindings"},{"location":"/limitations.html#type-qualifiers","text":"Type qualifiers const, volatile and restrict are not supported.","title":"Type qualifiers"},{"location":"/limitations.html#updating-extern-variables","text":"Extern variables are read-only. See scala-native/scala-native#202.","title":"Updating extern variables"},{"location":"/bindings/index.html","text":"","title":"Bindings"},{"location":"/bindings/index.html#bindings","text":"The following bindings have been generated with bindgen.\nPOSIX Iconv - Character set conversion Utf8proc - UTF-8 text processing","title":"Bindings"},{"location":"/bindings/posix.html","text":"","title":"POSIX"},{"location":"/bindings/posix.html#posix","text":"An addition to Scala Native’s POSIX bindings. To use one of the POSIX bindings you must add it as a dependency:\nsbt libraryDependencies += \"org.scala-native.bindgen\" %% \"libposix\" % \"0.3.0-RC2\" Maven <dependency>\n  <groupId>org.scala-native.bindgen</groupId>\n  <artifactId>libposix_2.11</artifactId>\n  <version>0.3.0-RC2</version>\n</dependency> Gradle dependencies {\n  compile group: 'org.scala-native.bindgen', name: 'libposix_2.11', version: '0.3.0-RC2'\n}\nBinding objects are available under the package name `\nHeader Description fnmatch.h Check if a file or path name matches a shell pattern regex.h Regular expression library","title":"POSIX"},{"location":"/bindings/posix.html#examples","text":"Using fnmatch.h:\nimport scala.scalanative.native._\nimport org.scalanative.bindgen.bindings.posix.fnmatch._\n\nassert(fnmatch(c\"*.md\", c\"README.md\", 0) == 0)\nassert(fnmatch(c\"*.[ch]\", c\"main.h\", 0) == 0)\nassert(fnmatch(c\"*.[ch]\", c\"main.c\", 0) == 0)\nassert(fnmatch(c\"*.md\", c\"README_md\", 0) == defines.FNM_NOMATCH)\nUsing regex.h:\nimport scala.scalanative.native._\nimport org.scalanative.bindgen.bindings.posix.regex._\n\nval reg = stackalloc[regex_t]\n\nval compResult =\n  regcomp(reg, c\"Scala \\\\(\\\\(J\\\\(VM\\\\|S\\\\)\\\\)\\\\|Native\\\\)\", 0)\nassert(compResult == 0)\n\nassert(regexec(reg, c\"Scala JVM\", 0, null, 0) == 0)\nassert(regexec(reg, c\"Scala JS\", 0, null, 0) == 0)\nassert(regexec(reg, c\"Scala Native\", 0, null, 0) == 0)\nassert(regexec(reg, c\"Scala .NET\", 0, null, 0) != 0)\n\nregfree(reg)","title":"Examples"},{"location":"/bindings/iconv.html","text":"","title":"Iconv - Character set conversion"},{"location":"/bindings/iconv.html#iconv-character-set-conversion","text":"To use this binding add the following dependency:\nsbt libraryDependencies += \"org.scala-native.bindgen\" %% \"libposix\" % \"0.3.0-RC2\" Maven <dependency>\n  <groupId>org.scala-native.bindgen</groupId>\n  <artifactId>libposix_2.11</artifactId>\n  <version>0.3.0-RC2</version>\n</dependency> Gradle dependencies {\n  compile group: 'org.scala-native.bindgen', name: 'libposix_2.11', version: '0.3.0-RC2'\n}\nThe iconv.h header allows to convert text between different character sets, for example UTF-8 to ISO-8859-1.","title":"Iconv - Character set conversion"},{"location":"/bindings/iconv.html#example","text":"import org.scalanative.bindgen.bindings.iconv.iconv._\nimport scala.scalanative.native._\nimport java.nio.charset.Charset\n\nval UTF8   = Charset.forName(\"UTF-8\")\nval encode = iconv_open(c\"UTF-8\", c\"ISO-8859-1\")\nval decode = iconv_open(c\"ISO-8859-1\", c\"UTF-8\")\n\nZone { implicit zone =>\n  val originalBuf    = toCString(\"øre\", UTF8) // Ear in Danish\n  val originalBufPtr = alloc[CString]\n  !originalBufPtr = originalBuf\n  val originalBytesLeft = alloc[CSize]\n  !originalBytesLeft = string.strlen(originalBuf)\n\n  val translatedBuf    = alloc[Byte](32)\n  val translatedBufPtr = alloc[CString]\n  !translatedBufPtr = translatedBuf\n  val translatedBytesLeft = alloc[CSize]\n  !translatedBytesLeft = 32\n\n  val translatedCode = iconv(\n    encode,\n    originalBufPtr,\n    originalBytesLeft,\n    translatedBufPtr,\n    translatedBytesLeft\n  )\n}\niconv_close(encode)","title":"Example"},{"location":"/bindings/utf8proc.html","text":"","title":"Utf8proc - UTF-8 text processing"},{"location":"/bindings/utf8proc.html#utf8proc-utf-8-text-processing","text":"This binding for utf8proc.h provides Unicode normalization, case-folding, and other operations for strings in the UTF-8 encoding.\nTo use it add the following dependency:\nsbt libraryDependencies += \"org.scala-native.bindgen\" %% \"libutf8proc\" % \"0.3.0-RC2\" Maven <dependency>\n  <groupId>org.scala-native.bindgen</groupId>\n  <artifactId>libutf8proc_2.11</artifactId>\n  <version>0.3.0-RC2</version>\n</dependency> Gradle dependencies {\n  compile group: 'org.scala-native.bindgen', name: 'libutf8proc_2.11', version: '0.3.0-RC2'\n}","title":"Utf8proc - UTF-8 text processing"},{"location":"/bindings/utf8proc.html#example","text":"import org.scalanative.bindgen.bindings.utf8proc.utf8proc._\nimport scala.scalanative.native._\n\nval text    = c\"Spørge\"\nval textlen = string.strlen(text)\n\nval codepoint        = stackalloc[utf8proc_int32_t]\nvar textpos: CSize   = 0\nvar textwidth: CSize = 0\n\nwhile (textpos < textlen) {\n  val bytes = utf8proc_iterate(\n    text.cast[Ptr[UByte]] + textpos,\n    textlen - textpos,\n    codepoint\n  )\n  textwidth += utf8proc_charwidth(!codepoint)\n  textpos += bytes\n}\n\nassert(textlen == 7)\nassert(textwidth == 6)","title":"Example"},{"location":"/contrib/index.html","text":"","title":"Contributors Guide"},{"location":"/contrib/index.html#contributors-guide","text":"Contributions to the project is very welcome. This section provides more information about how to build and contribute to the project.\nGuide for contributors Developer Workflow Coding Guidelines Building the executable with CMake Building the executable with docker-compose Contributing Bindings Adding a new Bindings Update all Bindings Release Workflow","title":"Contributor’s Guide"},{"location":"/contrib/guidelines.html","text":"","title":"Guide for contributors"},{"location":"/contrib/guidelines.html#guide-for-contributors","text":"Scala Native Bindgen follows Scala Native’s contributing guidelines. Larger contributions should always begin by creating an issue to ensure that it is properly scoped.\nImportant to note is that all contributors must have signed the Scala CLA.","title":"Guide for contributors"},{"location":"/contrib/guidelines.html#developer-workflow","text":"Build the scalaBindgen tool:\nmkdir bindgen/target\ncd bindgen/target\ncmake ..\nmake\n\n# Alternatively rerun on change\nwatchman-make -p '*.cpp' '*.h' --run 'make -C bindgen/target'\nIn another terminal, run the test suite:\ncd tests\nsbt ~test\nTo run the same tests as is run by Travis CI use the test.sh script, which will both build the executable and run sbt verify:\n./scripts/test.sh","title":"Developer Workflow"},{"location":"/contrib/guidelines.html#coding-guidelines","text":"Code should be formatted with ./scripts/scalafmt and ./scripts/clangfmt. Make sure that all of your contributions are properly formatted before suggesting any changes. You can check the formatting using either:\nscripts/scalafmt --test\nscripts/clangfmt --test\nor:\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 scripts/scalafmt --test\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 scripts/clangfmt --test\nThe C++ tool is built on Clang and Libtooling and should respect the conventions of LLVM and Clang tools. The code itself should adhere to the LLVM Coding Standards, specifically:\nFor code generation and error reporting use llvm::outs() and llvm::errs(). Use \\n instead of std::endl and remember to flush when reporting errors.","title":"Coding Guidelines"},{"location":"/contrib/cmake.html","text":"","title":"Building the executable with CMake"},{"location":"/contrib/cmake.html#building-the-executable-with-cmake","text":"Building scala-native-bindgen requires the following tools and libraries:\nCMake version 3.9 or higher GNU Make LLVM and Clang version 5.0 or 6.0. nlohmann/json version 3.1.2 or higher\n# On apt-based systems\napt install cmake make clang-6.0 libclang-6.0-dev llvm-6.0-dev \\\n            nlohmann-json-dev\n\n# With `brew`\nbrew tap nlohmann/json\nbrew install cmake llvm@6 nlohmann_json\nTo run the tests you also need the required Scala Native libraries. See the Scala Native setup guide for instructions on installing the dependencies.\nmkdir -p bindgen/target\ncd bindgen/target\ncmake ..\nmake\n./scala-native-bindgen --name ctype /usr/include/ctype.h --\nTo build a statically linked executable pass -DSTATIC_LINKING=ON when invoking cmake:\ncmake -DSTATIC_LINKING=ON ..\nAdditional compiler and linker flags may be passed as environment variable sor their CMake equivalent, e.g. to compile with debug symbols the following are the same:\ncmake -DCMAKE_CXX_FLAGS=-g ..\nCXXFLAGS=-g cmake ..","title":"Building the executable with CMake"},{"location":"/contrib/docker-compose.html","text":"","title":"Building the executable with docker-compose"},{"location":"/contrib/docker-compose.html#building-the-executable-with-docker-compose","text":"You can use docker-compose to build and test the program:\n# Build the docker image with LLVM version 6.0.\ndocker-compose build ubuntu-18.04-llvm-6.0\n# Build the bindgen tool and run the tests.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 ./script/test.sh\n# Run the bindgen tool inside the container.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 \\\n    bindgen/target/scala-native-bindgen --name union tests/samples/Union.h --","title":"Building the executable with docker-compose"},{"location":"/contrib/bindings.html","text":"","title":"Contributing Bindings"},{"location":"/contrib/bindings.html#contributing-bindings","text":"","title":"Contributing Bindings"},{"location":"/contrib/bindings.html#adding-a-new-bindings","text":"To add a new binding add a new project in build.sbt with the name of the artifact as well as a binding configuration for each header file and optionally the library to link with. The following example shows how it is possible to generate multiple bindings per project. For most libraries a single binding should be sufficient.\nlazy val libposix = bindingProject(\"posix\")\n  .configure(binding(\"fnmatch.h\"))\n  .configure(binding(\"regex.h\"))\nThe new sbt project should also be added to the bindings project’s list of aggregated projects.\nOptionally update the top-level Dockerfile to install the binding library’s -dev package.\n# Install binding dependencies\nRUN set -x \\\n && apt update \\\n && apt install -y --no-install-recommends \\\n\tlibutf8proc-dev \\\n && rm -rf /var/lib/apt/lists/*\nRemember to rebuild the development docker image if you change the Dockerfile.\ndocker-compose build ubuntu-18.04-llvm-6.0\nNext, run nativeBindgen to generate the bindings. Note, to ensure consistency the bindings should be generated in the Linux docker environment. This can be done by running:\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 sbt bindings/$BINDING/nativeBindgen\nThen write tests for the generated bindings. The test class should be in the org.scalanative.bindgen.bindings.tests package to make it easier to write examples for the binding documentation. Verify that the tests pass:\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 sbt bindings/$BINDING/test\nFinally, add a page in the bindings folder and document the binding, ideally with an example or two of how to use it.","title":"Adding a new Bindings"},{"location":"/contrib/bindings.html#update-all-bindings","text":"To update the bindings, build the Linux docker environment and run bindings/nativeBindgen:\ndocker-compose build ubuntu-18.04-llvm-6.0\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 sbt bindings/nativeBindgen\nRun the tests afterwards to verify that everything works:\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 sbt bindings/test","title":"Update all Bindings"},{"location":"/contrib/releasing.html","text":"","title":"Release Workflow"},{"location":"/contrib/releasing.html#release-workflow","text":"First build the scala-native-bindgen executable for both macOS and Linux:\nscripts/prepare-release.sh\nYou should now have scala-native-bindgen-linux and scala-native-bindgen-darwin if you ran the script on a macOS machine.\nThen release version x.y.z by running:\nsbt -Dproject.version=x.y.z release\nFinally, upload the scala-native-bindgen-linux and scala-native-bindgen-darwin executables to the release page at: https://github.com/kornilova-l/scala-native-bindgen/releases/tag/vx.y.z","title":"Release Workflow"}]}