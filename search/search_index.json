{"docs":[{"location":"/index.html","text":"","title":"Scala Native Bindgen"},{"location":"/index.html#scala-native-bindgen","text":"This tool generates Scala Native bindings from C headers. It’s built upon clang and LibTooling and thus respects the conventions of clang-tools.","title":"Scala Native Bindgen"},{"location":"/index.html#license","text":"This project is distributed under the Scala license. See LICENSE.txt for details","title":"License"},{"location":"/obtaining-bindgen/index.html","text":"","title":"Obtaining Bindgen"},{"location":"/obtaining-bindgen/index.html#obtaining-bindgen","text":"There are 3 ways to obtain bindgen:\nUse docker container Build binary with CMake Build binary with docker-compose","title":"Obtaining Bindgen"},{"location":"/obtaining-bindgen/docker-container.html","text":"","title":"Using Docker Container"},{"location":"/obtaining-bindgen/docker-container.html#using-docker-container","text":"This option requires Docker.\nDownload docker image with the binary:\ndocker pull scalabindgen/scala-native-bindgen\nMount directories with required header files and run bindgen:\ndocker run -v \"$(pwd)\":/src -v /usr/include:/usr/include \\\n  --rm scalabindgen/scala-native-bindgen \\\n  relative/path/to/my_header.h --name my_header --\nThe docker image does not contain standard headers so it is important to mount all system include directories that are used by the header file passed to scala-native-bindgen.\nSee the docker-bindgen.sh script for how to wrap the dockerized program. The $CWD of the container is /src which should be mounted from $(pwd) in case relative paths are used.\nNote, the scalabindgen/scala-native-bindgen:latest image is updated on each merge to the master branch.","title":"Using Docker Container"},{"location":"/obtaining-bindgen/cmake.html","text":"","title":"Building with CMake"},{"location":"/obtaining-bindgen/cmake.html#building-with-cmake","text":"Building scala-native-bindgen requires the following tools and libraries:\nCMake version 3.9 or higher LLVM and Clang version 5.0 or 6.0.\n# On apt-based systems\napt install cmake clang-$LLVM_VERSION libclang-$LLVM_VERSION-dev llvm-$LLVM_VERSION-dev\n\n# With `brew`\nbrew install cmake llvm@6\nTo run the tests you also need the required Scala Native libraries. See the Scala Native setup guide for instructions on installing the dependencies.\nmkdir -p bindgen/target\ncd bindgen/target\ncmake ..\nmake\n./scala-native-bindgen --name ctype /usr/include/ctype.h --\nTo build a statically linked executable pass -DSTATIC_LINKING=ON when invoking cmake:\ncmake -DSTATIC_LINKING=ON ..\nAdditional compiler and linker flags may be passed as environment variable sor their CMake equivalent, e.g. to compile with debug symbols the following are the same:\ncmake -DCMAKE_CXX_FLAGS=-g ..\nCXXFLAGS=-g cmake ..","title":"Building with CMake"},{"location":"/obtaining-bindgen/cmake.html#testing","text":"The tests assume that the above instructions for building scala-native-bindgen from source has been followed.\ncd tests\nsbt test","title":"Testing"},{"location":"/obtaining-bindgen/docker-compose.html","text":"","title":"Building with docker-compose"},{"location":"/obtaining-bindgen/docker-compose.html#building-with-docker-compose","text":"You can use docker-compose to build and test the program:\n# Build the docker image with LLVM version 6.0.\ndocker-compose build ubuntu-18.04-llvm-6.0\n# Build the bindgen tool and run the tests.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 ./script/test.sh\n# Run the bindgen tool inside the container.\ndocker-compose run --rm ubuntu-18.04-llvm-6.0 \\\n    bindgen/target/scala-native-bindgen --name union tests/samples/Union.h --","title":"Building with docker-compose"},{"location":"/command-line-usage/index.html","text":"","title":"Command Line Usage"},{"location":"/command-line-usage/index.html#command-line-usage","text":"Calling the tool is pretty easy, you need to specify the file(s) and the name of the created bindings.\nscala-native-bindgen --name uv /usr/include/uv.h --\nRunning the previous command wild also yield warnings along with the translation. To keep only the bindings please redirect the output to a file like this:\nscala-native-bindgen --name uv /usr/include/uv.h -- > uv.scala","title":"Command Line Usage"},{"location":"/command-line-usage/index.html#bindgen-options","text":"Option Description --link Library to link with, e.g. --link uv for libuv. --no-link Library does not require linking. --name Scala object name that contains bindings. Default value set to library name. --package Package name of generated Scala file. --exclude-prefix Functions and unused typedefs will be removed if their names have given prefix. --extra-arg Additional argument to append to the compiler command line. --extra-arg-before Additional argument to prepend to the compiler command line.","title":"Bindgen Options"},{"location":"/limitations/index.html","text":"","title":"Limitations"},{"location":"/limitations/index.html#limitations","text":"There are multiple unsupported cases that should be considered when generating bindings:\nCurrently bindgen does not support passing structs by value. For example, it will not be possible to call these two functions from Scala Native code: struct MyStruct {\n    int a;\n};\n\nstruct MyStruct returnStruct();\n\nvoid handleStruct(struct MyStruct mystr);\n To support such cases one should generate bindings for C wrapper functions that use pointers to structs instead of actual structs. #defines for literals and variables are supported. For other types of #defines, write wrapper functions that return defined values. // Supported\n#define ESC 0x1b            /* Defines for numerical and string literals. */\nextern const int pi_const;\n#define PI pi_const         /* Defines aliasing extern variables. */\n\n// Not supported (non-exhaustive list)\n#define COLS      (getenv(\"COLS\") ? atoi(getenv(\"COLS\")) : 80)\n#define MAX(a, b) (a > b ? a : b)\n There is no way to reuse already generated bindings. Bindgen outputs bindings also for headers that were included in a given header. See #2. Type qualifiers const, volatile and restrict are not supported. Extern variables are read-only. See scala-native/scala-native#202.","title":"Limitations"},{"location":"/using-generated-bindings/README.html","text":"","title":"Using Generated Bindings"},{"location":"/using-generated-bindings/README.html#using-generated-bindings","text":"Consider following header file:\nstruct point {\n    float x;\n    float y;\n};\n\nstruct vector {\n    struct point a;\n    struct point b;\n};\n\nstruct vector *add(struct vector *v1, struct vector *v2);\nBindgen will generate type aliases for the structs, binding for function add and helper functions that make usage of structs easier.\nimport scala.scalanative._\nimport scala.scalanative.native._\n\n@native.link(\"mylib\")\n@native.extern\nobject mylib {\n  type struct_point = native.CStruct2[native.CFloat, native.CFloat]\n  type struct_vector = native.CStruct2[struct_point, struct_point]\n  def add(v1: native.Ptr[struct_vector], v2: native.Ptr[struct_vector]): native.Ptr[struct_vector] = native.extern\n}\n\nimport mylib._\n\nobject mylibHelpers {\n\n  implicit class struct_point_ops(val p: native.Ptr[struct_point]) extends AnyVal {\n    def x: native.CFloat = !p._1\n    def x_=(value: native.CFloat): Unit = !p._1 = value\n    def y: native.CFloat = !p._2\n    def y_=(value: native.CFloat): Unit = !p._2 = value\n  }\n\n  def struct_point()(implicit z: native.Zone): native.Ptr[struct_point] = native.alloc[struct_point]\n\n  implicit class struct_vector_ops(val p: native.Ptr[struct_vector]) extends AnyVal {\n    def a: native.Ptr[struct_point] = p._1\n    def a_=(value: native.Ptr[struct_point]): Unit = !p._1 = !value\n    def b: native.Ptr[struct_point] = p._2\n    def b_=(value: native.Ptr[struct_point]): Unit = !p._2 = !value\n  }\n\n  def struct_vector()(implicit z: native.Zone): native.Ptr[struct_vector] = native.alloc[struct_vector]\n}\nLet’s write code that creates two vectors, adds them and prints resulting vector.\nFirst we need to create points for vectors. We will use native.Zone to allocate struct (more information on memory management can be found here: Scala Native memory management).\nHelper object mylibHelpers contains function for struct allocation. To import it use import mylibHelpers._\nLet’s create points for first vector:\nimport mylibHelpers._\nimport scala.scalanative.native.Zone\n\nobject Hello extends App {\n  Zone { implicit zone =>\n   val vec1p1 = struct_point()\n   val vec1p2 = struct_point()\n  }\n}\nNow we want to set fields of created points. Scala Native provides access to fields by using _N methods where N is index of a field (see Scala Native memory layout types).\nBindgen generates implicit helper classes that wrap calls to _N in functions with meaningful names. We already imported helper class, so we can use the functions:\nvec1p1.x = 0\nvec1p1.y = 1\n\nvec1p2.x = 6\nvec1p2.y = 3\nLets create first vector. Note that struct_vector contains fields of type struct_point but setters accept variables of type native.Ptr[struct_point]. It helps to avoid Scala Native limitation that does not allow passing structs and arrays by value (see scala-native/scala-native#555).\nval vec1 = struct_vector()\nvec1.a = vec1p1\nvec1.b = vec1p2\nRepeat these steps to create second vector. Once both vectors are created we can call add function and print the result:\nval vec3 = mylib.add(vec1, vec2)\nprintln(s\"(${vec3.a.x}, ${vec3.a.y}), (${vec3.b.x}, ${vec3.b.y})\")","title":"Using Generated Bindings"}]}